gegl-vips
=========

This is a quick proof-of-concept hack of gegl-0.1.6 to use libvips as the
backend. 

You need to have the development version of libvips installed (7.25), plus
babl-0.1.4 or later. Then configure ; make ; make install as usual.

Test program 
============

------
#include <stdio.h>
#include <stdlib.h>

#include <gegl.h>
#include <vips/vips.h>

int
main (int argc, char **argv)
{
  GeglNode *gegl, *load, *crop, *scale, *sharp, *save;

  g_thread_init (NULL);
  gegl_init (&argc, &argv);

  if (argc != 3) 
    {           
      fprintf (stderr, "usage: %s file-in file-out\n", argv[0]);
      exit (1);
    }
        
  gegl = gegl_node_new ();
        
  load = gegl_node_new_child (gegl,
                              "operation", "gegl:load",
                              "path", argv[1], 
                              NULL);
  printf( "load is node %p\n", load );

  crop = gegl_node_new_child (gegl, 
                              "operation", "gegl:crop",
                              "x", 100.0,
                              "y", 100.0,
                              "width", 4800.0, 
                              "height", 4800.0, 
                              NULL);
  printf( "crop is node %p\n", crop );
                
  scale = gegl_node_new_child (gegl,
                               "operation", "gegl:scale",
                               "x", 0.9,
                               "y", 0.9,
                               "filter", "linear", 
                               "hard-edges", FALSE, 
                               NULL);
  printf( "scale is node %p\n", scale );
                
  sharp = gegl_node_new_child (gegl,
                               "operation", "gegl:unsharp-mask",
                               "std-dev", 1.2, // diameter 7 mask in vips
                               //"std-dev", 1.0, // diameter 7 mask in gegl
                               NULL);
  printf( "sharp is node %p\n", sharp );

  save = gegl_node_new_child (gegl,
                              "operation", "gegl:save",
                              "path", argv[2], 
                              NULL);
  printf( "save is node %p\n", save );
                
  gegl_node_link_many (load, crop, scale, sharp, save, NULL);
 
  //gegl_node_dump( gegl, 0 );

  gegl_node_process (save);

  //gegl_node_dump( gegl, 0 );
                
  g_object_unref (gegl);

  gegl_exit ();

  return (0);
}
---

ie. load, crop 100 px off the edges (you need to give it a 5k x 5k RGB image),
bilinear 10% shrink, sharpen, save. See:

	http://www.vips.ecs.soton.ac.uk/index.php?title=Speed_and_Memory_Use

for results with other libraries.

Compile with:

   gcc -g -Wall gegl.c `pkg-config gegl vips-7.25 --cflags --libs`

and run with something like:

$ time ./a.out wtc_small.png wtc2.png

or 

$ time ./a.out wtc_small.tif wtc2.tif

(gegl-vips allows most image file formats)

Results
=======

On my laptop I get the following run times:

	- gegl-0.1.6, default settings, png output, 96s r, 44s u

I tried experimenting with various combinations of:

	export GEGL_THREADS=2
	export GEGL_SWAP=RAM
	export GEGL_CACHE_SIZE=10

but I couldn't make it faster, I probably missed something.

gegl-vips, identical processing

	- gegl-vips, tif files, 15s r, 23s u
	- gegl-vips, png files, 27s r, 38s u

no alpha

	- gegl-vips, tif files, 12s r, 18s u
	- gegl-vips, png files, 20s r, 20s u

use LUTs for int->float and back

	- gegl-vips, tif files, 3.9s r, 5.3s u
	- gegl-vips, png files, 14.8s r, 17.7s u

usharp redone as a single conv

	- gegl-vips, tif files, 2.9s r, 4.2s u
	- gegl-vips, png files, 12.6s r, 15.8s u

8-bit output

	- gegl-vips, tif files, 2.3s r, 4.0s u
	- gegl-vips, png files, 6.0s r, 8.4s u

8-bit path 

	- gegl-vips, tif files, 1.0s r, 1.5s u
	- gegl-vips, png files, 3.2s r, 4.0s u

Conclusions
===========

In the most comparable case, gegl-vips needs about 10s less CPU
but finished 70s earlier, perhaps due to my slow laptop harddrive and
gegl's tile cache. libvips has a nice threading system and double-buffered
write-behind, which help too.

Using a relatively fast, uncompressed file format (tif) saves 15s.

Dropping the alpha channel (not needed in this case) saves 5s.

Use LUTs for linearization, save 12s.

Faster convolution, save 1s.

8-bit output (we don't really need 16 bit in this case) gives a small saving
for tif, but a large saving for png.

A complete 8-bit path, save 3s.

How it works
============

- add this to every GeglNode:

	VipsImage *vips_image;
	guint64 vips_hash;

- in every operation (I've only done load/save/crop/affine/usharp) change the
  GeglOperation::process() member to be something like this (this is crop):

  GeglNode *input;
  guint64 hash;

  // make sure input is ready
  input = gegl_operation_get_source_node (operation, "input");
  if (!input || !input->vips_image)
    return;

  // calculate a hash of the input args
  hash = 0;
  hash = GEGL_VIPS_HASH_POINTER (hash, input->vips_image);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->x);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->y);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->width);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->height);

  // if args have changed, or this is the first time we've run
  if (!node->vips_image || node->vips_hash != hash)
    {
      VipsImage *image;

      // perform the equivalent vips operation
      image = vips_image_new ("p");
      if (im_extract_area (input->vips_image, image,
			   o->x, o->y, o->width, o->height))
	{
	  gegl_vips_error ("crop");
	  g_object_unref (image);
	  return;
	}

      // install the new image on the node, update the hash
      if (node->vips_image)
        {
	  g_object_unref (node->vips_image);
	  node->vips_image = NULL;
	}
      node->vips_image = image;
      node->vips_hash = hash;
    }

- change gegl_node_process() to simply walk the graph, bottom-up, calling all 
  the prepare() members 

... and that's about it, very simple.

TODO:

- add a display sink
- try a couple more operations
- maybe get hello-world.c working
- vips needs area invalidation before we can support destructive operations

