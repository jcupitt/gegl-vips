gegl-vips

This is a quick proof-of-concept hack of gegl-0.1.6 to use libvips as the
backend. 

You need to have the development version of libvips installed (7.25), plus
babl-0.1.4 or later. Then configure ; make ; make install as usual.

This is the test program we support:

------
#include <stdio.h>
#include <stdlib.h>

#include <gegl.h>
#include <vips/vips.h>

int
main (int argc, char **argv)
{
  GeglNode *gegl, *load, *crop, *scale, *sharp, *save;

  g_thread_init (NULL);
  gegl_init (&argc, &argv);

  if (argc != 3) 
    {           
      fprintf (stderr, "usage: %s file-in file-out\n", argv[0]);
      exit (1);
    }
        
  gegl = gegl_node_new ();
        
  load = gegl_node_new_child (gegl,
                              "operation", "gegl:load",
                              "path", argv[1], 
                              NULL);
  printf( "load is node %p\n", load );

  crop = gegl_node_new_child (gegl, 
                              "operation", "gegl:crop",
                              "x", 100.0,
                              "y", 100.0,
                              "width", 4800.0, 
                              "height", 4800.0, 
                              NULL);
  printf( "crop is node %p\n", crop );
                
  scale = gegl_node_new_child (gegl,
                               "operation", "gegl:scale",
                               "x", 0.9,
                               "y", 0.9,
                               "filter", "linear", 
                               "hard-edges", FALSE, 
                               NULL);
  printf( "scale is node %p\n", scale );
                
  sharp = gegl_node_new_child (gegl,
                               "operation", "gegl:unsharp-mask",
                               "std-dev", 1.2, // diameter 7 mask in vips
                               //"std-dev", 1.0, // diameter 7 mask in gegl
                               NULL);
  printf( "sharp is node %p\n", sharp );

  save = gegl_node_new_child (gegl,
                              "operation", "gegl:save",
                              "path", argv[2], 
                              NULL);
  printf( "save is node %p\n", save );
                
  gegl_node_link_many (load, crop, scale, sharp, save, NULL);
 
  //gegl_node_dump( gegl, 0 );

  gegl_node_process (save);

  //gegl_node_dump( gegl, 0 );
                
  g_object_unref (gegl);

  gegl_exit ();

  return (0);
}
---

ie. load, crop 100 px off the edges (you need to give it a 5k x 5k RGB image),
bilinear 10% shrink, sharpen, save

compile with:

   gcc -g -Wall gegl.c `pkg-config gegl vips-7.25 --cflags --libs`

and run with something like:

$ time ./a.out wtc_small.png wtc2.png

or 

$ time ./a.out wtc_small.tif wtc2.tif

(gegl-vips allows most image file formats)

On my laptop I get the following run times:

   timing:

- gegl-0.1.6, default settings, png output, 96s r, 44s u

gegl-vips, identical processing

- gegl-vips, tif files, 15s r, 23s u
- gegl-vips, png files, 27s r, 38s u

no alpha

- gegl-vips, tif files, 12s r, 18s u
- gegl-vips, png files, 20s r, 20s u

use LUTs for int->float and back

- gegl-vips, tif files, 3.9s r, 5.3s u
- gegl-vips, png files, 14.8s r, 17.7s u

8-bit output

- gegl-vips, tif files, 3.3s r, 5.1s u
- gegl-vips, png files, 7.9s r, 10.5s u

8-bit path 

- gegl-vips, tif files, 2.4s r, 3.4s u
- gegl-vips, png files, 7.7s r, 8.7s u

ushaprp redone as a single conv

- gegl-vips, tif files, 1.2s r, 1.5s u
- gegl-vips, png files, 3.4s r, 4s u

Conclusions: in the most comparable case, gegl-vips needs about 10s less CPU
but finished much earlier, perhaps due to the slow laptop harddrive and
gegl's tile cache.

Fast, uncompressed formats like tiff can save 10s.

The alpha costs another 3s.

Use LUTs for linearization, save another 8s.

8-bit output, save 0.5s.

8-bit path, save 1s.

Faster convolution, save 1s.

How it works:

- add this to every GeglNode:

	VipsImage *vips_image;
	guint64 vips_hash;

- in every operation (I've only done load/save/crop/affine/usharp) change the
  GeglOperation::process() member to be something like this (this is crop):

  GeglNode *input;
  guint64 hash;

  // make sure input is ready
  input = gegl_operation_get_source_node (operation, "input");
  if (!input || !input->vips_image)
    return;

  // calculate a hash of the input args
  hash = 0;
  hash = GEGL_VIPS_HASH_POINTER (hash, input->vips_image);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->x);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->y);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->width);
  hash = GEGL_VIPS_HASH_DOUBLE (hash, o->height);

  // if args have changed, or this is the first time we've run
  if (!node->vips_image || node->vips_hash != hash)
    {
      VipsImage *image;

      // perform the equivalent vips operation
      image = vips_image_new ("p");
      if (im_extract_area (input->vips_image, image,
			   o->x, o->y, o->width, o->height))
	{
	  gegl_vips_error ("crop");
	  g_object_unref (image);
	  return;
	}

      // install the new image on the node, update the hash
      if (node->vips_image)
        {
	  g_object_unref (node->vips_image);
	  node->vips_image = NULL;
	}
      node->vips_image = image;
      node->vips_hash = hash;
    }

- change gegl_node_process() to simply walk the graph, bottom-up, calling all 
  the prepare() members 

... and that's about it, very simple.

TODO:

- add a display sink
- try a couple more operations
- maybe get hello-world.c working
- vips needs area invalidation before we can support destructive operations

